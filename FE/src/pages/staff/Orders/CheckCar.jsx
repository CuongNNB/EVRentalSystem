import React, { useMemo, useState } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import StaffSlideBar from "../../../components/staff/StaffSlideBar";
import StaffHeader from "../../../components/staff/StaffHeader";
import api from "../../../utils/api";
import {
  DEFAULT_INSPECTION_STATUS,
  ROW_INSPECTION_SLOTS,
  buildInspectionSlots,
  getInspectionPart,
} from "../../../utils/inspectionParts";
import "../StaffLayout.css";
import "./CheckCar.css";

const CheckCar = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { orderId = "EV0205010" } = useParams();
  const [photos, setPhotos] = useState({});
  const [descriptions, setDescriptions] = useState({}); // Th√™m state cho descriptions
  const [notification, setNotification] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [additionalRows, setAdditionalRows] = useState([]);

  const staffId = useMemo(() => {
    const state = location.state || {};
    const candidates = [
      state.staffId,
      state.order?.staffId,
      state.order?.staff?.id,
      state.order?.raw?.staffId,
      state.order?.raw?.staff?.id,
    ];
    if (typeof window !== "undefined") {
      try {
        const cachedUser = window.localStorage.getItem("ev_user");
        if (cachedUser) {
          const parsedUser = JSON.parse(cachedUser);
          candidates.push(parsedUser?.id);
          candidates.push(parsedUser?.userId);
          candidates.push(parsedUser?.staffId);
        }
      } catch (storageError) {
        console.warn("Unable to read cached staff profile", storageError);
      }
    }
    for (const candidate of candidates) {
      if (candidate !== undefined && candidate !== null) {
        const normalized = Number(candidate);
        if (!Number.isNaN(normalized)) {
          return normalized;
        }
      }
    }
    return null;
  }, [location.state]);

  const photoSlots = useMemo(
    () => buildInspectionSlots(additionalRows),
    [additionalRows]
  );
  const allowedSlotIds = useMemo(() => new Set(photoSlots.map((slot) => slot.id)), [photoSlots]);
  const optionalRowSlots = useMemo(
    () => ROW_INSPECTION_SLOTS.filter((slot) => slot.id !== "row1" && slot.id !== "row2"),
    []
  );
  const handleAddRow = (rowId) => {
    setAdditionalRows((prev) => (prev.includes(rowId) ? prev : [...prev, rowId]));
  };
  const remainingRowSlots = useMemo(
    () => optionalRowSlots.filter((slot) => !additionalRows.includes(slot.id)),
    [optionalRowSlots, additionalRows]
  );
  const bookingId = useMemo(() => {
    const state = location.state || {};
    const candidates = [
      state.bookingId,
      state.order?.id,
      state.order?.orderId,
      state.order?.raw?.id,
      state.order?.raw?.bookingId,
      state.order?.raw?.orderId,
      orderId,
    ];
    for (const candidate of candidates) {
      if (candidate !== undefined && candidate !== null) {
        const normalized = String(candidate).trim();
        if (normalized) return normalized;
      }
    }
    return "";
  }, [location.state, orderId]);

  const handleUpload = (event, slotId) => {
  const file = event.target.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onloadend = () => {
    setPhotos((prev) => ({
      ...prev,
      [slotId]: {
        file,                // l∆∞u file th·∫≠t ƒë·ªÉ g·ª≠i BE
        preview: reader.result, // base64 ch·ªâ ƒë·ªÉ hi·ªÉn th·ªã
      },
    }));
  };

  reader.readAsDataURL(file); // d√πng cho preview th√¥i
};


  const handleSendToCustomer = async () => {
  if (isSending) return;
  setErrorMessage("");
  setNotification("");

  if (!bookingId) {
    setErrorMessage("Kh√¥ng t√¨m th·∫•y m√£ ƒë∆°n h√†ng ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i.");
    return;
  }

  if (!staffId) {
    setErrorMessage("Kh√¥ng t√¨m th·∫•y m√£ nh√¢n vi√™n ƒë·ªÉ t·∫°o bi√™n b·∫£n ki·ªÉm tra.");
    return;
  }

  const photoEntries = Object.entries(photos).filter(
    ([slotId, value]) => allowedSlotIds.has(slotId) && value?.file
  );

  // Validation: Ki·ªÉm tra c√≥ √≠t nh·∫•t 1 ·∫£nh
  if (photoEntries.length === 0) {
    setErrorMessage("Vui l√≤ng t·∫£i l√™n √≠t nh·∫•t m·ªôt ·∫£nh ki·ªÉm tra xe.");
    return;
  }


  setIsSending(true);

  try {
    let successCount = 0;
    let failCount = 0;

    for (const [slotId, data] of photoEntries) {
      const partName = getInspectionPart(slotId);
      if (!partName) continue;

      try {
        // üîπ D√πng FormData ƒë·ªÉ g·ª≠i file
        const formData = new FormData();
        formData.append("bookingId", bookingId);
        formData.append("partName", partName);
        formData.append("picture", data.file);
        formData.append("description", descriptions[slotId] || ""); // Th√™m description
        formData.append("staffId", staffId);
        formData.append("status", DEFAULT_INSPECTION_STATUS);

        await api.post("/api/inspections/create", formData, {
          headers: { "Content-Type": "multipart/form-data" },
        });
        
        successCount++;
      } catch (inspectionError) {
        console.error(`Failed to create inspection for ${partName}:`, inspectionError);
        failCount++;
      }
    }

    // N·∫øu kh√¥ng c√≥ inspection n√†o th√†nh c√¥ng, d·ª´ng l·∫°i
    if (successCount === 0) {
      setErrorMessage("Kh√¥ng th·ªÉ t·∫°o bi√™n b·∫£n ki·ªÉm tra. Vui l√≤ng th·ª≠ l·∫°i.");
      setIsSending(false);
      return;
    }


    // G·ªçi API c·∫≠p nh·∫≠t tr·∫°ng th√°i booking
    try {
      await api.put(`/api/bookings/${encodeURIComponent(bookingId)}/status`, null, {
        params: { status: "Vehicle_Inspected_Before_Pickup" },
      });
    } catch (statusError) {
      console.warn("Unable to update booking status", statusError);
      // V·∫´n cho ph√©p ti·∫øp t·ª•c v√¨ inspections ƒë√£ ƒë∆∞·ª£c t·∫°o
    }

    const message = failCount > 0
      ? `ƒê√£ g·ª≠i ${successCount}/${photoEntries.length} ·∫£nh ki·ªÉm tra. ${failCount} ·∫£nh th·∫•t b·∫°i.`
      : `ƒê√£ g·ª≠i bi√™n b·∫£n ki·ªÉm tra v·ªõi ${successCount} ·∫£nh cho kh√°ch h√†ng.`;
    
    setNotification(message);
    
    setTimeout(() => {
      navigate("/staff/orders", { replace: true });
    }, 2000);
  } catch (error) {
    console.error("Error during inspection submission:", error);
    setErrorMessage(
      error.response?.data?.message || 
      "Kh√¥ng th·ªÉ t·∫°o bi√™n b·∫£n ki·ªÉm tra ho·∫∑c c·∫≠p nh·∫≠t tr·∫°ng th√°i. Vui l√≤ng th·ª≠ l·∫°i."
    );
    setIsSending(false);
  }
};


  return (
    <div className="staff-shell staff-shell--orders">
      <StaffHeader />
      <div className="staff-layout staff-layout--orders">
        <StaffSlideBar activeKey="orders" />
        <main className="staff-main">
          <section className="return-check">
            <header className="return-check__header">
              <h1>
                Qu·∫£n l√Ω b√†n giao xe <span># {orderId}</span>
              </h1>
              <p>Ki·ªÉm tra xe tr∆∞·ªõc khi giao</p>
            </header>

            {notification && (
              <div className="return-check__toast" role="status">
                <span className="return-check__toast-icon" aria-hidden="true">
                  ‚úÖ
                </span>
                <div>
                  <p className="return-check__toast-title">ƒê√£ g·ª≠i cho kh√°ch</p>
                  <p className="return-check__toast-message">{notification}</p>
                </div>
              </div>
            )}
            {errorMessage && (
              <div
                className="return-check__toast"
                role="alert"
                style={{ background: "rgba(248, 113, 113, 0.18)", color: "#b91c1c" }}
              >
                <span className="return-check__toast-icon" aria-hidden="true">
                  ‚ö†Ô∏è
                </span>
                <div>
                  <p className="return-check__toast-title">G·ª≠i th·∫•t b·∫°i</p>
                  <p className="return-check__toast-message">{errorMessage}</p>
                </div>
              </div>
            )}

            <div className="return-check__layout">
              <section className="return-check__panel return-check__panel--gallery">
                <header className="return-check__panel-header">
                  <h2>·∫¢nh ki·ªÉm tra</h2>
                  <p>T·∫£i l√™n h√¨nh ·∫£nh minh ch·ª©ng cho t·ª´ng g√≥c ch·ª•p.</p>
                </header>

                <div className="return-check__photos">
                  {photoSlots.map((slot) => (
                    <div 
                      key={slot.id} 
                      className={`return-check__photo-slot-wrapper ${
                        photos[slot.id]?.preview ? 'return-check__photo-slot-wrapper--active' : ''
                      }`}
                    >
                      {/* Photo Upload */}
                      <label className="return-check__photo-slot">
                        <input
                          type="file"
                          accept="image/*"
                          onChange={(event) => handleUpload(event, slot.id)}
                        />
                        <div className="return-check__photo-frame">
                          {photos[slot.id]?.preview ? (
                            <img
                              src={photos[slot.id].preview}
                              alt={slot.label}
                              className="return-check__photo-img"
                            />
                          ) : (
                            <span className="return-check__photo-placeholder" aria-hidden="true">
                              üì∑
                            </span>
                          )}
                        </div>
                        <p className="return-check__photo-label">{slot.label}</p>
                      </label>
                      
                      {/* Description - ch·ªâ hi·ªán khi ƒë√£ c√≥ ·∫£nh */}
                      {photos[slot.id]?.preview && (
                        <div className="return-check__photo-description-wrapper">
                          <label htmlFor={`desc-${slot.id}`} className="return-check__photo-description-label">
                            üí¨ M√¥ t·∫£ cho ·∫£nh n√†y:
                          </label>
                          <textarea
                            id={`desc-${slot.id}`}
                            className="return-check__photo-description"
                            placeholder={`V√≠ d·ª•: "Kh√¥ng c√≥ v·∫øt x∆∞·ªõc", "ƒê√®n ho·∫°t ƒë·ªông t·ªët"...`}
                            value={descriptions[slot.id] || ""}
                            onChange={(e) => setDescriptions(prev => ({
                              ...prev,
                              [slot.id]: e.target.value
                            }))}
                            rows={2}
                          />
                          <span className="return-check__photo-description-hint">
                            {descriptions[slot.id]?.length || 0} k√Ω t·ª±
                          </span>
                        </div>
                      )}
                    </div>
                  ))}
                  {remainingRowSlots.map((slot) => (
                    <div key={slot.id} className="return-check__add-row-wrapper">
                      <button
                        type="button"
                        className="return-check__add-row-button"
                        onClick={() => handleAddRow(slot.id)}
                      >
                        <div className="return-check__add-row-icon">
                          <span className="return-check__add-row-plus">+</span>
                        </div>
                        <span className="return-check__add-row-label">Th√™m {slot.label}</span>
                      </button>
                    </div>
                  ))}
                </div>
              </section>

            </div>

            <footer className="return-check__actions">
              <button
                type="button"
                className="return-check__action"
                onClick={() => navigate(-1)}
              >
                ‚Üê Tr·ªü v·ªÅ ch·ªçn xe
              </button>
              <div className="return-check__action-group">
                <button
                  type="button"
                  className="return-check__action return-check__action--primary"
                  onClick={handleSendToCustomer}
                  disabled={isSending}
                >
                  {isSending ? "ƒêang g·ª≠i..." : "G·ª≠i cho kh√°ch"}
                </button>
              </div>
            </footer>
          </section>
        </main>
      </div>
    </div>
  );
};

export default CheckCar;

